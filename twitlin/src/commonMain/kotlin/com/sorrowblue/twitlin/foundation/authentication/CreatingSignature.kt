package com.sorrowblue.twitlin.foundation.authentication

import com.github.aakira.napier.Napier
import com.sorrowblue.twitlin.net.hmacSHA1
import com.sorrowblue.twitlin.utils.urlEncode

/**
 * Collecting parameters
 *
 * Next, gather all of the parameters included in the request.
 * There are two such locations for these additional parameters - the URL (as part of the query string) and the request body.
 *
 * @param consumerKey The [consumerKey] identifies which application is making the request.
 * Obtain this value from the settings page for your [Twitter app](https://developer.twitter.com/en/docs/basics/developer-portal/guides/apps)
 * in the [developer portal](https://developer.twitter.com/en/docs/basics/developer-portal/overview).
 * @param nonce The [nonce] parameter is a unique token your application should generate for each unique request.
 * Twitter will use this value to determine whether a request has been submitted multiple times.
 * The value for this request was generated by base64 encoding 32 bytes of random data, and stripping out all non-word characters,
 * but any approach which produces a relatively random alphanumeric string should be OK here.
 * @param timestamp The [timestamp] parameter indicates when the request was created.
 * This value should be the number of seconds since the Unix epoch at the point the request is generated,
 * and should be easily generated in most programming languages.
 * Twitter will reject requests which were created too far in the past,
 * so it is important to keep the clock of the computer generating requests in sync with NTP.
 * @param oauthToken The [oauthToken] parameter typically represents a user’s permission to share access to their account with your application.
 * There are a few authentication requests where this value is not passed or is a different form of token,
 * but those are covered in detail in [Obtaining access tokens](https://developer.twitter.com/en/docs/basics/authentication/oauth-1-0a).
 * For most general-purpose requests, you will use what is referred to as an access token.
 *
 * You can generate a valid [access token](https://developer.twitter.com/en/docs/basics/authentication/oauth-1-0a)
 * for your account on the settings page for your [Twitter app](https://developer.twitter.com/en/docs/basics/developer-portal/guides/apps)
 * on the [developer portal](https://developer.twitter.com/en/docs/basics/developer-portal/overview).
 * @param params
 * @return
 */
internal fun collectParameters(
	consumerKey: String,
	nonce: String,
	timestamp: String,
	oauthToken: String?,
	params: List<Pair<String, String>>
): String = listOf(
	"oauth_consumer_key" to consumerKey,
	"oauth_nonce" to nonce,
	"oauth_signature_method" to "HMAC-SHA1",
	"oauth_timestamp" to timestamp,
	"oauth_version" to "1.0"
).plus(params).run { oauthToken?.let { plus("oauth_token" to it) } ?: this }
	// 1. Percent encode every key and value that will be signed.
	.map { it.first.urlEncode() to it.second.urlEncode() }
	// 2. Sort the list of parameters alphabetically [1] by encoded key [2].
	.sortedBy { it.first }
	// 3. Append the encoded key to the output string.
	// 4. Append the ‘=’ character to the output string.
	// 5. Append the encoded value to the output string.
	// 6. If there are more key/value pairs remaining, append a ‘&’ character to the output string.
	.joinToString("&") { "${it.first}=${it.second}" }
	.also { Napier.i("collectParameters() = $it", tag = "TwitlinClient") }

/**
 * Creating the signature base string
 *
 * The three values collected so far must be joined to make a single string, from which the signature will be generated.
 * This is called the signature base string by the OAuth specification.
 * To encode the HTTP method, base URL, and parameter string into a single string:
 *
 * @param parameterString
 * @return
 */
internal fun creatingSignatureBaseString(method: String, url: String, parameterString: String) =
	StringBuilder()
		// 1. Convert the HTTP Method to uppercase and set the output string equal to this value.
		.append(method)
		// 2. Append the ‘&’ character to the output string.
		.append("&")
		// 3. Percent encode the URL and append it to the output string.
		.append(url.urlEncode())
		// 4. Append the ‘&’ character to the output string.
		.append("&")
		// 5. Percent encode the parameter string and append it to the output string.
		.append(parameterString.urlEncode())
		.toString()
		.also { Napier.i("creatingSignatureBaseString() = $it", tag = "TwitlinClient") }

/**
 * Getting a signing key
 *
 * The last pieces of data to collect are secrets which identify
 * the [Twitter app](https://developer.twitter.com/en/docs/basics/developer-portal/guides/apps) making the request,
 * and the user the request is on behalf of.
 * It is very important to note that these values are incredibly sensitive and should never be shared with anyone.
 *
 * @param consumerSecret The value which identifies your app to Twitter is called the **consumer secret**
 * and can be found in the [developer portal](https://developer.twitter.com/en/docs/basics/developer-portal/overview)
 * by viewing the [app details page](https://developer.twitter.com/en/docs/basics/developer-portal/guides/apps).
 * This will be the same for every request your Twitter app sends.
 * @param oAuthTokenSecret The value which identifies the account your application is acting on behalf of is called the **OAuth token secret**.
 * This value can be obtained in several ways, all of which are described
 * in [obtaining access tokens](https://developer.twitter.com/en/docs/basics/authentication/oauth-1-0a).
 */
internal fun getSigningKey(consumerSecret: String, oAuthTokenSecret: String?) =
	"$consumerSecret&${oAuthTokenSecret.orEmpty()}"

internal fun calculateSignature(baseString: String, signingKey: String) =
	hmacSHA1(signingKey.encodeToByteArray(), baseString.encodeToByteArray())
