package com.sorrowblue.twitlin.foundation

import com.sorrowblue.twitlin.net.encodeNoPaddingBase64
import com.sorrowblue.twitlin.net.hmacSHA1
import com.sorrowblue.twitlin.utils.urlEncode
import com.soywiz.klock.DateTime
import io.ktor.client.request.*
import kotlin.random.Random

fun generateNonce() = Random.nextBytes(32).decodeToString().encodeNoPaddingBase64()
fun generateTimestamp() = (DateTime.nowUnixLong() / 1000).toString()
fun Array<out Pair<String, Any?>>.notNullParams() = mapNotNull {
	if (it.second != null) it.first to it.second.toString() else null
}

internal fun buildHeaderString(
	consumerKey: String,
	nonce: String,
	signature: String,
	timestamp: String,
	oauthToken: String?,
	appEnd: List<Pair<String, String>> = emptyList()
): String {
	val list = mutableListOf(
		"oauth_consumer_key" to consumerKey,
		"oauth_nonce" to nonce,
		"oauth_signature" to signature,
		"oauth_signature_method" to "HMAC-SHA1",
		"oauth_timestamp" to timestamp,
	).apply {
		oauthToken?.let { add("oauth_token" to oauthToken) }
		add("oauth_version" to "1.0")
		addAll(appEnd)
	}.sortedBy { it.first }
	val dst = StringBuilder()
	dst.append("OAuth ")
	list.forEachIndexed { index, pair ->
		dst.append(pair.first.urlEncode())
		dst.append("=")
		dst.append("\"")
		dst.append(pair.second.urlEncode())
		dst.append("\"")
		if (index != list.lastIndex) {
			dst.append(", ")
		}
	}
	return dst.toString()
}

/**
 * Collecting parameters
 *
 * Next, gather all of the parameters included in the request.
 * There are two such locations for these additional parameters - the URL (as part of the query string) and the request body.
 *
 * @param consumerKey The [consumerKey] identifies which application is making the request.
 * Obtain this value from the settings page for your [Twitter app](https://developer.twitter.com/en/docs/basics/developer-portal/guides/apps)
 * in the [developer portal](https://developer.twitter.com/en/docs/basics/developer-portal/overview).
 * @param nonce The [nonce] parameter is a unique token your application should generate for each unique request.
 * Twitter will use this value to determine whether a request has been submitted multiple times.
 * The value for this request was generated by base64 encoding 32 bytes of random data, and stripping out all non-word characters,
 * but any approach which produces a relatively random alphanumeric string should be OK here.
 * @param timestamp The [timestamp] parameter indicates when the request was created.
 * This value should be the number of seconds since the Unix epoch at the point the request is generated,
 * and should be easily generated in most programming languages.
 * Twitter will reject requests which were created too far in the past,
 * so it is important to keep the clock of the computer generating requests in sync with NTP.
 * @param oauthToken The [oauthToken] parameter typically represents a user’s permission to share access to their account with your application.
 * There are a few authentication requests where this value is not passed or is a different form of token,
 * but those are covered in detail in [Obtaining access tokens](https://developer.twitter.com/en/docs/basics/authentication/oauth-1-0a).
 * For most general-purpose requests, you will use what is referred to as an access token.
 *
 * You can generate a valid [access token](https://developer.twitter.com/en/docs/basics/authentication/oauth-1-0a)
 * for your account on the settings page for your [Twitter app](https://developer.twitter.com/en/docs/basics/developer-portal/guides/apps)
 * on the [developer portal](https://developer.twitter.com/en/docs/basics/developer-portal/overview).
 * @param params
 * @return
 */
internal fun collectParametersForSignature(
	consumerKey: String,
	nonce: String,
	timestamp: String,
	oauthToken: String?,
	params: List<Pair<String, Any?>>,
): String = listOf(
	"oauth_consumer_key" to consumerKey,
	"oauth_nonce" to nonce,
	"oauth_signature_method" to "HMAC-SHA1",
	"oauth_timestamp" to timestamp,
	"oauth_version" to "1.0"
).plus(params)
	.run { oauthToken?.let { plus("oauth_token" to it) } ?: this }
	.map { it.first.urlEncode() to it.second?.toString()?.urlEncode() }
	.sortedBy { it.first }
	.joinToString("&") { "${it.first}=${it.second}" }

/**
 * Creating the signature base string
 *
 * The three values collected so far must be joined to make a single string, from which the signature will be generated.
 * This is called the signature base string by the OAuth specification.
 * To encode the HTTP method, base URL, and parameter string into a single string:
 *
 * @param parameterString
 * @return
 */
internal fun HttpRequestBuilder.creatingSignatureBaseString(parameterString: String) =
	StringBuilder()
		// 1. Convert the HTTP Method to uppercase and set the output string equal to this value.
		.append(method.value)
		// 2. Append the ‘&’ character to the output string.
		.append("&")
		// 3. Percent encode the URL and append it to the output string.
		.append("${url.protocol.name}://${url.host}${url.encodedPath}".urlEncode())
		// 4. Append the ‘&’ character to the output string.
		.append("&")
		// 5. Percent encode the parameter string and append it to the output string.
		.append(parameterString.urlEncode())
		.toString()

/**
 * Getting a signing key
 *
 * The last pieces of data to collect are secrets which identify
 * the [Twitter app](https://developer.twitter.com/en/docs/basics/developer-portal/guides/apps) making the request,
 * and the user the request is on behalf of.
 * It is very important to note that these values are incredibly sensitive and should never be shared with anyone.
 *
 * @param consumerSecret The value which identifies your app to Twitter is called the **consumer secret**
 * and can be found in the [developer portal](https://developer.twitter.com/en/docs/basics/developer-portal/overview)
 * by viewing the [app details page](https://developer.twitter.com/en/docs/basics/developer-portal/guides/apps).
 * This will be the same for every request your Twitter app sends.
 * @param oAuthTokenSecret The value which identifies the account your application is acting on behalf of is called the **OAuth token secret**.
 * This value can be obtained in several ways, all of which are described
 * in [obtaining access tokens](https://developer.twitter.com/en/docs/basics/authentication/oauth-1-0a).
 */
internal fun getSigningKey(consumerSecret: String, oAuthTokenSecret: String?) =
	"$consumerSecret&${oAuthTokenSecret.orEmpty()}"

internal fun calculateSignature(baseString: String, signingKey: String) =
	hmacSHA1(signingKey.encodeToByteArray(), baseString.encodeToByteArray())

/**
 * Creating a signature
 *
 * This explains how to generate an OAuth 1.0a HMAC-SHA1 signature for an HTTP request.
 * This signature will be suitable for passing to the Twitter API as part of an authorized request,
 * as described in [authorizing a request](https://developer.twitter.com/en/docs/basics/authentication/oauth-1-0a/authorizing-a-request).
 *
 * @param consumerKey
 * @param consumerSecret
 * @param nonce
 * @param timestamp
 * @param oauthToken
 * @param params
 * @return
 */
internal fun HttpRequestBuilder.createSignature(
	consumerKey: String,
	consumerSecret: String,
	nonce: String,
	timestamp: String,
	oauthToken: String?,
	oauthTokenSecret: String?,
	params: List<Pair<String, Any?>>,
): String {
	val parameterString =
		collectParametersForSignature(consumerKey, nonce, timestamp, oauthToken, params)
	val baseString = creatingSignatureBaseString(parameterString)
	val signingKey = getSigningKey(consumerSecret, oauthTokenSecret)
	return calculateSignature(baseString, signingKey)
}
