package com.sorrowblue.twitlin.core

import com.sorrowblue.twitlin.core.util.hmacSHA1
import com.sorrowblue.twitlin.core.util.urlEncode
import io.ktor.util.InternalAPI
import io.ktor.util.encodeBase64

/**
 * Collecting parameters
 *
 * Next, gather all the parameters included in the request.
 * There are two such locations for these additional parameters - the URL (as part of the query string) and the request body.
 *
 * @param consumerKey The [consumerKey] identifies which application is making the request.
 * Obtain this value from the settings page for your [Twitter app](https://developer.twitter.com/en/docs/basics/developer-portal/guides/apps)
 * in the [developer portal](https://developer.twitter.com/en/docs/basics/developer-portal/overview).
 * @param nonce The [nonce] parameter is a unique token your application should generate for each unique request.
 * Twitter will use this value to determine whether a request has been submitted multiple times.
 * The value for this request was generated by base64 encoding 32 bytes of random data, and stripping out all non-word characters,
 * but any approach which produces a relatively random alphanumeric string should be OK here.
 * @param timestamp The [timestamp] parameter indicates when the request was created.
 * This value should be the number of seconds since the Unix epoch at the point the request is generated,
 * and should be easily generated in most programming languages.
 * Twitter will reject requests which were created too far in the past,
 * so it is important to keep the clock of the computer generating requests in sync with NTP.
 * @param oauthToken The [oauthToken] parameter typically represents a user’s permission to share access to their account with your application.
 * There are a few authentication requests where this value is not passed or is a different form of token,
 * but those are covered in detail in [Obtaining access tokens](https://developer.twitter.com/en/docs/basics/authentication/oauth-1-0a).
 * For most general-purpose requests, you will use what is referred to as an access token.
 *
 * You can generate a valid [access token](https://developer.twitter.com/en/docs/basics/authentication/oauth-1-0a)
 * for your account on the settings page for your [Twitter app](https://developer.twitter.com/en/docs/basics/developer-portal/guides/apps)
 * on the [developer portal](https://developer.twitter.com/en/docs/basics/developer-portal/overview).
 * @param params
 * @return
 */
internal fun collectingParameters(
    consumerKey: String,
    nonce: String,
    timestamp: String,
    oauthToken: String?,
    params: List<Pair<String, String>>
): String {
    return listOf(
        "oauth_consumer_key" to consumerKey,
        "oauth_nonce" to nonce,
        "oauth_signature_method" to "HMAC-SHA1",
        "oauth_timestamp" to timestamp,
        "oauth_version" to "1.0"
    ).plus(params).run { oauthToken?.let { plus("oauth_token" to it) } ?: this }
        // 1. Percent encode every key and value that will be signed.
        .map { it.first.urlEncode() to it.second.urlEncode() }
        // 2. Sort the list of parameters alphabetically [1] by encoded key [2].
        .sortedBy { it.first }
        // 3. Append the encoded key to the output string.
        // 4. Append the ‘=’ character to the output string.
        // 5. Append the encoded value to the output string.
        // 6. If there are more key/value pairs remaining, append a ‘&’ character to the output string.
        .joinToString("&") { "${it.first}=${it.second}" }
}

/**
 * Creating the signature base string
 *
 * The three values collected so far must be joined to make a single string, from which the signature will be generated.
 * This is called the signature base string by the OAuth specification.
 * To encode the HTTP method, base URL, and parameter string into a single string:
 *
 * @param parameterString
 * @return
 */
internal fun creatingSignatureBaseString(
    method: String,
    url: String,
    parameterString: String
): String {
    return StringBuilder()
        // 1. Convert the HTTP Method to uppercase and set the output string equal to this value.
        .append(method)
        // 2. Append the ‘&’ character to the output string.
        .append("&")
        // 3. Percent encode the URL and append it to the output string.
        .append(url.urlEncode())
        // 4. Append the ‘&’ character to the output string.
        .append("&")
        // 5. Percent encode the parameter string and append it to the output string.
        .append(parameterString.urlEncode())
        .toString()
}

/**
 * Getting a signing key
 *
 * The last pieces of data to collect are secrets which identify
 * the [Twitter app](https://developer.twitter.com/en/docs/basics/developer-portal/guides/apps) making the request,
 * and the user the request is on behalf of.
 * It is very important to note that these values are incredibly sensitive and should never be shared with anyone.
 *
 * @param consumerSecret The value which identifies your app to Twitter is called the **consumer secret**
 * and can be found in the [developer portal](https://developer.twitter.com/en/docs/basics/developer-portal/overview)
 * by viewing the [app details page](https://developer.twitter.com/en/docs/basics/developer-portal/guides/apps).
 * This will be the same for every request your Twitter app sends.
 * @param oAuthTokenSecret The value which identifies the account your application is acting on behalf of is called the **OAuth token secret**.
 * This value can be obtained in several ways, all of which are described
 * in [obtaining access tokens](https://developer.twitter.com/en/docs/basics/authentication/oauth-1-0a).
 */
internal fun gettingSigningKey(consumerSecret: String, oAuthTokenSecret: String?): String =
    "$consumerSecret&${oAuthTokenSecret.orEmpty()}"

/**
 * Finally, the signature is calculated by passing the signature base string and signing key to the
 * HMAC-SHA1 hashing algorithm. The details of the algorithm are explained as hash_hmac function.
 * The output of the HMAC signing function is a binary string. This needs to be base64 encoded to
 * produce the signature string.
 *
 * @param baseString
 * @param signingKey
 * @return
 */
internal fun calculateSignature(baseString: String, signingKey: String): ByteArray =
    hmacSHA1(signingKey.encodeToByteArray(), baseString.encodeToByteArray())

/**
 * Finally, the signature is calculated by passing the signature base string and signing key to the
 * HMAC-SHA1 hashing algorithm. The details of the algorithm are explained as hash_hmac function.
 * The output of the HMAC signing function is a binary string. This needs to be base64 encoded to
 * produce the signature string.
 *
 * @param baseString
 * @param signingKey
 * @return
 */
@OptIn(InternalAPI::class)
internal fun calculateSignatureBase64(baseString: String, signingKey: String): String =
    calculateSignature(baseString, signingKey).encodeBase64()
